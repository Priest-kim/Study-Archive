# LeetCode 496. Next Greater Element I

## 문제 설명

다음으로 큰 원소를 찾는 문제입니다.

nums1과 nums2 두 개의 서로 다른 0-인덱스 정수 배열이 주어집니다. nums1은 nums2의 부분집합입니다.

nums1의 각 원소에 대해, nums2에서 해당 원소의 다음으로 큰 원소를 찾아야 합니다.

nums1[i]의 다음으로 큰 원소는 nums2에서 nums1[i]의 오른쪽에 있는 첫 번째로 큰 원소입니다. 존재하지 않으면 -1입니다.

### 예제

**Example 1:**

- Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
- Output: [-1,3,-1]
- 설명: nums1의 각 원소에 대해:
- 4는 nums2 = [1,3,4,2]에서 오른쪽에 더 큰 수가 없으므로 다음으로 큰 원소는 -1입니다.
- 1은 nums2 = [1,3,4,2]에서 다음으로 큰 원소는 3입니다.
- 2는 nums2 = [1,3,4,2]에서 오른쪽에 더 큰 수가 없으므로 다음으로 큰 원소는 -1입니다.

**Example 2:**

- Input: nums1 = [2,4], nums2 = [1,2,3,4]
- Output: [3,-1]
- 설명: nums1의 각 원소에 대해:
- 2는 nums2 = [1,2,3,4]에서 다음으로 큰 원소는 3입니다.
- 4는 nums2 = [1,2,3,4]에서 오른쪽에 더 큰 수가 없으므로 다음으로 큰 원소는 -1입니다.

## 제한사항

- 1 <= nums1.length <= nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 10^4
- nums1과 nums2의 모든 정수는 고유함
- nums1의 모든 정수는 nums2에도 나타남

## 문제 풀이

문제는 nums1에 요소들이 nums2를 순회 하면서 현재 값이 현재 값 기준으로 오른쪽에 있는 요소들 중에 기준 값보다 큰 값 중 가장 가까운 값을 구하고 만약 없다면 -1을 반환하는 문제이다.
우선 이중 반복문들 돌리면 되는 문제 이지만 좀 더 효율 적인 방법인 map과 stack 자료구조를 이용하여 문제 풀이 를 해보겠다.

우선 stack에 nums2를 순회하며 쌓는다 그러면서 배열울 순회(오른쪽)으로 순회하면서 stack의 가장 마지막에 들어온 값과 i의 값을 비교하며 만약 stack.pop() 값보다 큰 값을 찾고 찾았다면 map에 비교의 기준값( stack) : 타겟값(stack보다 큰값)을 저장한다.
이렇게 저장하고 나면 nums2의 요소들 중 오른쪽에 자신보다 큰값이 존재하는 값만 해당 값과 매칭되어 저장되게 된다.

map값을 가지고 nums1을 순회하며 값을대입해 리턴을 하면 된다.
